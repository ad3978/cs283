1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

I made my shell wait for all child processes to finish before showing the next prompt. After creating multiple child processes for piped commands, my shell goes through each one and calls waitpid() on it. This function makes the shell pause until the child process is done. I use a for loop to wait for each process one by one. Only after all processes have finished does the shell display the next prompt. I also made sure to close all pipe connections in the parent process to avoid wasting system resources.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

After using dup2() to connect pipes between processes, I closed the original pipe ends that were no longer needed because my program could have run out of file descriptors, which were limited resources in the system or some programs in my pipeline might never have finished because they would have been waiting for more data from a pipe that stayed open. Open pipes also waste memory and CPU resources as the system kept checking them for activity. That's why after each dup2() call, we close the original pipe ends to keep the shell working correctly

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

The cd command needs to be built into the shell rather than run as an external command because of how processes work with directories. When a shell runs a normal external command like ls or grep, it creates a child process that runs separately and then reports back. If cd were an external command, the child process would change its own directory and then exit, but this change wouldn't affect the main shell process. The parent shell would stay in the same directory as before. That's why cd must be built directly into the shell code so that the shell itself changes its own working directory using the chdir() system call. This way, all future commands the shell runs will start in the new directory.

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

To support any number of piped commands in my shell instead of a fixed limit, I would change the way memory is handled. Instead of creating fixed-size arrays for commands, pipes, and process IDs, I would make them grow as needed. I'd start with space for a few commands and then use realloc() to double the size whenever more space is needed. There's a performance trade-off since constantly growing arrays can slow things down if there are many commands. I'd still need some reasonable upper limits to prevent problems like running out of file descriptors
